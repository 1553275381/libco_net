本以为一个变量声明为 volatile 之后，多线程每次从内存访问会杜绝race condition，但是我错了
具体程序见 test/multi_threads 

仔细想想，多线程访问一个int变量应该是：
1. volatile 表示访问一个变量的一种方式，是把读取的内存放到寄存器以后方便以后读取，还是每次都要访问内存
2. 真正发生问题的原因是，
	1) 线程t1读取 a = 10 到寄存器 eax 后，[eax]自加1后，此时寄存器值为11，
	2) 这时线程t1切换为t2后，读取 a = 10 的值后再次覆盖 eax (ps:此时eax为11) 为10，eax自加1后，此时t2时间片足够，eax写回内存 a = 11
	3) 此时t2切换回t1，t1要把寄存器eax（此时eax=11）回写到a = 11
	4) 所以 a 被两个线程各执行一次，结果只累加了一次。

总结：由于线程切换的缘故，导致寄存器错位的读取，最终结果偏差



假设操作前global值为5。

　　[线程1]                                                                                                                    [线程2]

　　movl global,%eax;   #global值为5,%eax值为5
　　addl $1,%eax;       #%eax值为6
　　                                                               --------此时线程2获取执行权限--------->
　　                                                                                                                         movl global,%eax;  #global值为5,%eax值为5
　　                                                                                                                         addl $1,%eax;      #%eax值为6
　　                                                                                                                         movl %eax,global;  #%eax值为6，global值为6
　　                                                               <--------执行权交回线程1-------------- 
　　movl %eax,global;   #%eax值为6,global值为6

　　由上述例子可以看出，结果并非我们预计的global的值连加2次，而是由5变为了6。这就是多线程下非原子操作有可能产生的问题。

