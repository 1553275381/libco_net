大端：高地址在低字节，低地址在高字节
小端：高地址在高字节，低地址在低字节

网络是大端;

union {
	short   s;
	char[2] c;
} u;

u.s = 0x0102;
if(u.c[0] == 0x01) /* 低地址在高字节 */
{
	printf("大端\n");
}
else
{
	printf("小端\n");
}

----------------------------------------------------------------

Q: 为何网络是大端？
A: 大端小端之分
小端字节序和大端字节序表示存储的字节顺序有区别
小端字节序：低字节存于内存低地址；高字节存于内存高地址;
long型数据0x12345678
在小端系统中，

地址	数据
0x00000100	0x78
0x00000101	0x56
0x00000102	0x34
0x00000103	0x12
内存的地址是由低到高的顺序；而数据的字节也是由低到高的

大端字节序：高字节存于内存低地址；低字节存于内存高地址;
long型数据0x12345678
在大端系统中，

地址	数据
0x00000100	0x12
0x00000101	0x34
0x00000102	0x56
0x00000103	0x78
内存的地址是由低到高的顺序；而数据的字节却是由高到低的

网络字节序
网络上传输的数据都是字节流,对于一个多字节数值,在进行网络传输的时候,先传递哪个字节?也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有意义的问题;
UDP/TCP/IP协议规定:把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节;而在发送端发送数据时,发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);由此可见,多字节数值在发送之前,在内存中因该是以大端法存放的;
所以说,网络字节序是大端字节序;比如,我们经过网络发送整型数值0x12345678时,在80X86平台中,它是以小端发存放的,在发送之前需要使用系统提供的字节序转换函数htonl()将其转换成大端法存放的数值;
